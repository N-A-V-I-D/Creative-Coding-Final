{"ast":null,"code":"const https = require('https');\n\nconst search = async word => {\n  try {\n    if (!word || word.trim() == \"\") throw new Error(\"no word defined.\"); // get webpage html\n\n    let body = await sendRequest(word); // extract cats & words\n\n    const cats = body.match(/ty\"\\>(\\w+\\.)<\\/td>/g);\n    const words = body.match(/td\"\\>(.+[^;])<\\/td>/g); // store meanings with their categories\n\n    const meanings = []; // check if meanings for the given word are found\n\n    if (cats == null || cats.length == 0) {\n      return meanings;\n    } // extract meanings and categories\n\n\n    cats.forEach((catData, i) => {\n      let cat = catData.substring(catData.lastIndexOf('\"ty\">') + 5, catData.lastIndexOf(\"</td>\"));\n      const wordData = words[i];\n      let word = wordData.substring(wordData.lastIndexOf('\"td\">') + 5, wordData.lastIndexOf(\"</td>\"));\n      meanings.push({\n        category: cat.trim(),\n        meaning: word.trim()\n      });\n    });\n    return meanings;\n  } catch (error) {\n    // if request failed, throw error\n    throw new Error(error);\n  }\n};\n\nconst sendRequest = word => {\n  return new Promise((resolve, reject) => {\n    https.get(encodeURI(`https://www.maduraonline.com/?find=${word}`), resp => {\n      let data = ''; // A chunk of data has been recieved.\n\n      resp.on('data', chunk => {\n        data += chunk;\n      }); // The whole response has been received. Print out the result.\n\n      resp.on('end', () => {\n        resolve(data);\n      });\n    }).on(\"error\", err => {\n      reject(err.message);\n    });\n  });\n};\n\nmodule.exports = {\n  search\n};","map":{"version":3,"names":["https","require","search","word","trim","Error","body","sendRequest","cats","match","words","meanings","length","forEach","catData","i","cat","substring","lastIndexOf","wordData","push","category","meaning","error","Promise","resolve","reject","get","encodeURI","resp","data","on","chunk","err","message","module","exports"],"sources":["/Users/navid/Documents/Final Project 2/vocab/node_modules/@ipmanlk/madura-api/lib/madura.js"],"sourcesContent":["const https = require('https');\n\nconst search = async (word) => {\n    try {\n        if (!word || word.trim() == \"\") throw new Error(\"no word defined.\");\n\n        // get webpage html\n        let body = await sendRequest(word);\n\n        // extract cats & words\n        const cats = body.match(/ty\"\\>(\\w+\\.)<\\/td>/g);\n        const words = body.match(/td\"\\>(.+[^;])<\\/td>/g);\n\n        // store meanings with their categories\n        const meanings = [];\n\n        // check if meanings for the given word are found\n        if (cats == null || cats.length == 0) {\n            return meanings;\n        }\n\n        // extract meanings and categories\n        cats.forEach((catData, i) => {\n\n            let cat = catData.substring(\n                catData.lastIndexOf('\"ty\">') + 5,\n                catData.lastIndexOf(\"</td>\")\n            );\n\n            const wordData = words[i];\n            let word = wordData.substring(\n                wordData.lastIndexOf('\"td\">') + 5,\n                wordData.lastIndexOf(\"</td>\")\n            );\n\n            meanings.push({\n                category: cat.trim(),\n                meaning: word.trim()\n            });\n\n        });\n\n        return (meanings);\n\n    } catch (error) {\n        // if request failed, throw error\n        throw new Error(error);\n    }\n}\n\nconst sendRequest = (word) => {\n    return new Promise((resolve, reject) => {\n        https.get(encodeURI(`https://www.maduraonline.com/?find=${word}`), (resp) => {\n            let data = '';\n\n            // A chunk of data has been recieved.\n            resp.on('data', (chunk) => {\n                data += chunk;\n            });\n\n            // The whole response has been received. Print out the result.\n            resp.on('end', () => {\n                resolve(data);\n            });\n\n        }).on(\"error\", (err) => {\n            reject(err.message);\n        });\n\n    });\n}\n\nmodule.exports = {\n    search\n}"],"mappings":"AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AAEA,MAAMC,MAAM,GAAG,MAAOC,IAAP,IAAgB;EAC3B,IAAI;IACA,IAAI,CAACA,IAAD,IAASA,IAAI,CAACC,IAAL,MAAe,EAA5B,EAAgC,MAAM,IAAIC,KAAJ,CAAU,kBAAV,CAAN,CADhC,CAGA;;IACA,IAAIC,IAAI,GAAG,MAAMC,WAAW,CAACJ,IAAD,CAA5B,CAJA,CAMA;;IACA,MAAMK,IAAI,GAAGF,IAAI,CAACG,KAAL,CAAW,qBAAX,CAAb;IACA,MAAMC,KAAK,GAAGJ,IAAI,CAACG,KAAL,CAAW,sBAAX,CAAd,CARA,CAUA;;IACA,MAAME,QAAQ,GAAG,EAAjB,CAXA,CAaA;;IACA,IAAIH,IAAI,IAAI,IAAR,IAAgBA,IAAI,CAACI,MAAL,IAAe,CAAnC,EAAsC;MAClC,OAAOD,QAAP;IACH,CAhBD,CAkBA;;;IACAH,IAAI,CAACK,OAAL,CAAa,CAACC,OAAD,EAAUC,CAAV,KAAgB;MAEzB,IAAIC,GAAG,GAAGF,OAAO,CAACG,SAAR,CACNH,OAAO,CAACI,WAAR,CAAoB,OAApB,IAA+B,CADzB,EAENJ,OAAO,CAACI,WAAR,CAAoB,OAApB,CAFM,CAAV;MAKA,MAAMC,QAAQ,GAAGT,KAAK,CAACK,CAAD,CAAtB;MACA,IAAIZ,IAAI,GAAGgB,QAAQ,CAACF,SAAT,CACPE,QAAQ,CAACD,WAAT,CAAqB,OAArB,IAAgC,CADzB,EAEPC,QAAQ,CAACD,WAAT,CAAqB,OAArB,CAFO,CAAX;MAKAP,QAAQ,CAACS,IAAT,CAAc;QACVC,QAAQ,EAAEL,GAAG,CAACZ,IAAJ,EADA;QAEVkB,OAAO,EAAEnB,IAAI,CAACC,IAAL;MAFC,CAAd;IAKH,CAlBD;IAoBA,OAAQO,QAAR;EAEH,CAzCD,CAyCE,OAAOY,KAAP,EAAc;IACZ;IACA,MAAM,IAAIlB,KAAJ,CAAUkB,KAAV,CAAN;EACH;AACJ,CA9CD;;AAgDA,MAAMhB,WAAW,GAAIJ,IAAD,IAAU;EAC1B,OAAO,IAAIqB,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;IACpC1B,KAAK,CAAC2B,GAAN,CAAUC,SAAS,CAAE,sCAAqCzB,IAAK,EAA5C,CAAnB,EAAoE0B,IAAD,IAAU;MACzE,IAAIC,IAAI,GAAG,EAAX,CADyE,CAGzE;;MACAD,IAAI,CAACE,EAAL,CAAQ,MAAR,EAAiBC,KAAD,IAAW;QACvBF,IAAI,IAAIE,KAAR;MACH,CAFD,EAJyE,CAQzE;;MACAH,IAAI,CAACE,EAAL,CAAQ,KAAR,EAAe,MAAM;QACjBN,OAAO,CAACK,IAAD,CAAP;MACH,CAFD;IAIH,CAbD,EAaGC,EAbH,CAaM,OAbN,EAagBE,GAAD,IAAS;MACpBP,MAAM,CAACO,GAAG,CAACC,OAAL,CAAN;IACH,CAfD;EAiBH,CAlBM,CAAP;AAmBH,CApBD;;AAsBAC,MAAM,CAACC,OAAP,GAAiB;EACblC;AADa,CAAjB"},"metadata":{},"sourceType":"script"}